{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to Discord-Qalib","text":"<p>Qalib (Arabic: \u0642\u0627\u0644\u0628), which means template in Arabic, is the official name of this library.</p>"},{"location":"#what-is-discord-qalib","title":"What is  Discord-Qalib?","text":"<p>Discord-Qalib is an extension that wraps around and extends discord.py Context instance, allowing for templated responses so that front-end facing text is separated from the source code and placed in a file in a structured manner (i.e. <code>.xml</code>, <code>.json</code>).</p>"},{"location":"#simple-usage","title":"Simple Usage","text":"<p>A simple example <code>.xml</code> file would be</p> <pre><code>&lt;discord&gt;\n&lt;message key=\"balance\"&gt;\n&lt;embed&gt;\n&lt;title&gt;Hello {player.name}&lt;/title&gt;\n&lt;colour&gt;cyan&lt;/colour&gt;\n&lt;fields&gt;\n&lt;field&gt;\n&lt;title&gt;Balance Remaining&lt;/title&gt;\n&lt;value&gt;\u00a3 {player.balance}&lt;/value&gt;\n&lt;/field&gt;\n&lt;/fields&gt;\n&lt;/embed&gt;\n&lt;/message&gt;\n&lt;/discord&gt;\n</code></pre> <p>stored as <code>balance.xml</code> in the templates directory</p> <p>and can be used in the source code as such</p> <pre><code>from dataclasses import dataclass\nfrom typing import Literal\nimport discord\nfrom discord.ext import commands\nimport qalib\nfrom qalib.template_engines.formatter import Formatter\nbot = commands.AutoShardedBot(command_prefix=\"!\", intents=discord.Intents.all())\nMessages = Literal[\"balance\"]\n@dataclass\nclass Player:\nname: str\nbalance: float\n@bot.command()\n@qalib.qalib_context(Formatter(), \"templates/balance.xml\")\ndef balance(ctx: qalib.QalibContext[Messages], name: str):\nawait ctx.rendered_send(\"balance\", keywords={\"player\": Player(name, 1000.0)})\n</code></pre>"},{"location":"about/","title":"About","text":"<p>This library was created to fulfill the idea of separating the text from the source code.</p> <p>If you have issues, please report them here.</p>"},{"location":"qalib/context/","title":"Context","text":"<p>             Bases: <code>Context</code>, <code>Generic[K_contra]</code></p> <p>QalibContext object is responsible for handling messages that are to be sent to the client.</p>"},{"location":"qalib/context/#qalib.context.QalibContext.__init__","title":"<code>__init__(ctx, renderer)</code>","text":"<p>Constructor for the QalibContext object</p> <p>Parameters:</p> <ul> <li> <code>ctx</code>             (<code>context</code>)         \u2013          <p>context object that is passed to the command</p> </li> <li> <code>renderer</code>             (<code>RendererProxy</code>)         \u2013          <p>renderer object that is used to render the embeds and views</p> </li> </ul>"},{"location":"qalib/context/#qalib.context.QalibContext.display","title":"<code>display(key, callables=None, keywords=None, events=None, **kwargs)</code>  <code>async</code>","text":"<p>this is the main function that we use to send one message, and one message only. However, edits to that message can take place.</p> <p>Parameters:</p> <ul> <li> <code>key</code>             (<code>str</code>)         \u2013          <p>identifies the embed in the route file</p> </li> <li> <code>callables</code>             (<code>Optional[Dict[str, Callback]]</code>, default:                 <code>None</code> )         \u2013          <p>callable coroutines that are called when the user interacts</p> </li> <li> <code>keywords</code>             (<code>Optional[Dict[str, Any]]</code>, default:                 <code>None</code> )         \u2013          <p>keywords that are passed to the embed renderer to format the text</p> </li> <li> <code>events</code>             (<code>Optional[EventCallback]</code>, default:                 <code>None</code> )         \u2013          <p>callbacks that are called on the event</p> </li> <li> <code>**kwargs</code>         \u2013          <p>kwargs that are passed to the context send method or the message edit method</p> </li> </ul> <p>Returns (discord.message.Message): Message object that got sent to the client.</p>"},{"location":"qalib/context/#qalib.context.QalibContext.get_message","title":"<code>get_message()</code>  <code>async</code>","text":"<p>This method waits for a message to be sent by the user</p>"},{"location":"qalib/context/#qalib.context.QalibContext.menu","title":"<code>menu(key, callbacks=None, keywords=None, events=None, **kwargs)</code>  <code>async</code>","text":"<p>This method is used to create a menu for the user to select from.</p> <p>Parameters:</p> <ul> <li> <code>key</code>             (<code>K</code>)         \u2013          <p>identifies the menu in the template file</p> </li> <li> <code>callbacks</code>             (<code>Dict[str, Callback]</code>, default:                 <code>None</code> )         \u2013          <p>callbacks that are called when the user interacts with the menu</p> </li> <li> <code>keywords</code>             (<code>Dict[str, Any]</code>, default:                 <code>None</code> )         \u2013          <p>keywords that are passed to the embed renderer to format the text</p> </li> <li> <code>events</code>             (<code>Optional[EventCallback]</code>, default:                 <code>None</code> )         \u2013          <p>callbacks that are called on the event</p> </li> <li> <code>**kwargs</code>         \u2013          <p>kwargs that are passed to the context's send method</p> </li> </ul>"},{"location":"qalib/context/#qalib.context.QalibContext.rendered_send","title":"<code>rendered_send(identifier, callables=None, keywords=None, events=None, **kwargs)</code>  <code>async</code>","text":"<p>Methods that is fires a message to the client and returns the message object. Doesn't save/keep track of the message.</p> <p>Parameters:</p> <ul> <li> <code>identifier</code>             (<code>str</code>)         \u2013          <p>identifies the embed in the route file</p> </li> <li> <code>callables</code>             (<code>Optional[Dict[str, Callback]]) </code>, default:                 <code>None</code> )         \u2013          <p>functions that are hooked to components</p> </li> <li> <code>keywords</code>             (<code>Dict[str, Any]</code>, default:                 <code>None</code> )         \u2013          <p>keywords that are passed to the embed renderer to format the text</p> </li> <li> <code>events</code>             (<code>Optional[EventCallback]</code>, default:                 <code>None</code> )         \u2013          <p>callbacks that are called on the event</p> </li> <li> <code>**kwargs</code>         \u2013          <p>kwargs that are passed to the context's send method</p> </li> </ul> <p>Returns (discord.message.Message): Message object that got sent to the client.</p>"},{"location":"qalib/context/#qalib.context.QalibContext.verify","title":"<code>verify(message)</code>","text":"<p>Method verifies if the content of the message is in the contents</p> <p>Parameters:</p> <ul> <li> <code>message</code>             (<code>Message</code>)         \u2013          <p>message that is getting verified</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>bool</code> (            <code>bool</code> )        \u2013          <p>true of false that indicates whether the data is valid.</p> </li> </ul>"},{"location":"qalib/interaction/","title":"Interaction","text":"<p>             Bases: <code>Interaction</code>, <code>Generic[K_contra]</code></p> <p>The QalibInteraction class is a subclass of discord.Interaction, and is used to add additional functionality to the interaction. It is meant to be used in the on_interaction event, and is responsible for deserializing the requested modal and sending it to the user.</p>"},{"location":"qalib/interaction/#qalib.interaction.QalibInteraction.__init__","title":"<code>__init__(interaction, renderer)</code>","text":"<p>Constructor method for the QalibInteraction class.</p>"},{"location":"qalib/interaction/#qalib.interaction.QalibInteraction.display","title":"<code>display(key, callables=None, keywords=None, events=None, **kwargs)</code>  <code>async</code>","text":"<p>this is the main function that we use to send one message, and one message only. However, edits to that message can take place.</p> <p>Parameters:</p> <ul> <li> <code>key</code>             (<code>K</code>)         \u2013          <p>identifies the message in the template file</p> </li> <li> <code>callables</code>             (<code>Optional[Dict[str, Callback]]</code>, default:                 <code>None</code> )         \u2013          <p>callable coroutines that are called when the user interacts with the message</p> </li> <li> <code>keywords</code>             (<code>Optional[Dict[str, Any]]</code>, default:                 <code>None</code> )         \u2013          <p>keywords that are passed to the embed renderer to format the text</p> </li> <li> <code>events</code>             (<code>Optional[EventCallback]</code>, default:                 <code>None</code> )         \u2013          <p>callbacks that are called on the event.</p> </li> <li> <code>**kwargs</code>         \u2013          <p>kwargs that are passed to the context send method or the message edit method</p> </li> </ul> <p>Returns (discord.message.Message): Message object that got sent to the client.</p>"},{"location":"qalib/interaction/#qalib.interaction.QalibInteraction.menu","title":"<code>menu(key, callbacks=None, keywords=None, **kwargs)</code>  <code>async</code>","text":"<p>This method is used to create a menu for the user to select from.</p> <p>Parameters:</p> <ul> <li> <code>key</code>             (<code>K</code>)         \u2013          <p>identifies the menu in the template file</p> </li> <li> <code>callbacks</code>             (<code>Dict[str, Callback]</code>, default:                 <code>None</code> )         \u2013          <p>callbacks that are called when the user interacts with the menu</p> </li> <li> <code>keywords</code>             (<code>Dict[str, Any]</code>, default:                 <code>None</code> )         \u2013          <p>keywords that are passed to the embed renderer to format the text</p> </li> <li> <code>**kwargs</code>         \u2013          <p>kwargs that are passed to the context's send method</p> </li> </ul>"},{"location":"qalib/interaction/#qalib.interaction.QalibInteraction.rendered_send","title":"<code>rendered_send(identifier, callables=None, keywords=None, events=None, **kwargs)</code>  <code>async</code>","text":"<p>Methods that is fires a message to the client and returns the message object. Doesn't save/keep track of the message.</p> <p>Parameters:</p> <ul> <li> <code>identifier</code>             (<code>str</code>)         \u2013          <p>identifies the embed in the route file</p> </li> <li> <code>callables</code>             (<code>Optional[Dict[str, Callback]]) </code>, default:                 <code>None</code> )         \u2013          <p>functions that are hooked to components</p> </li> <li> <code>keywords</code>             (<code>Dict[str, Any]</code>, default:                 <code>None</code> )         \u2013          <p>keywords that are passed to the embed renderer to format the text</p> </li> <li> <code>events</code>             (<code>Optional[EventCallback]</code>, default:                 <code>None</code> )         \u2013          <p>callbacks that are hooked to the event.</p> </li> <li> <code>**kwargs</code>         \u2013          <p>kwargs that are passed to the context's send method</p> </li> </ul> <p>Returns (discord.message.Message): Message object that got sent to the client.</p>"},{"location":"qalib/interaction/#qalib.interaction.QalibInteraction.respond_with_modal","title":"<code>respond_with_modal(key, methods=None, keywords=None)</code>  <code>async</code>","text":"<p>Method that is responsible for templating the document, and then deserializing the requested modal based on its key and sending it to the user.</p> <p>Parameters:</p> <ul> <li> <code>methods</code>             (<code>Dict[str, Callback]</code>, default:                 <code>None</code> )         \u2013          <p>methods that are used to override the default methods of the modal</p> </li> <li> <code>key</code>             (<code>str</code>)         \u2013          <p>key that identifies the modal in the route file</p> </li> <li> <code>keywords</code>             (<code>Any</code>, default:                 <code>None</code> )         \u2013          <p>keywords that are passed to the modal renderer to format the text</p> </li> </ul>"},{"location":"qalib/renderer/","title":"Renderer","text":"<p>             Bases: <code>Generic[K_contra]</code></p> <p>This object is responsible for rendering the embeds, views, and menus, by first using the templating engine to template the document, and then using the deserializer to deserialize the document into embeds and views.</p>"},{"location":"qalib/renderer/#qalib.renderer.Renderer.render","title":"<code>render(key, callbacks=None, keywords=None, events=None)</code>","text":"<p>This method is used to render an embed and a view, and places it in a NamedTuple</p> <p>Parameters:</p> <ul> <li> <code>key</code>             (<code>K</code>)         \u2013          <p>key of the embed,</p> </li> <li> <code>callbacks</code>             (<code>Optional[Dict[str, Callable]]</code>, default:                 <code>None</code> )         \u2013          <p>callbacks that are attached to the components of the view,</p> </li> <li> <code>keywords</code>             (<code>Dict[str, Any]</code>, default:                 <code>None</code> )         \u2013          <p>keywords that are passed to the embed renderer to format the text,</p> </li> <li> <code>events</code>             (<code>Optional[EventCallbacks]</code>, default:                 <code>None</code> )         \u2013          <p>callbacks that are called on events</p> </li> </ul> <p>Returns (ReturnType): All possible deserialized types</p>"},{"location":"qalib/deserializers/deserializer/","title":"Deserializer","text":"<p>             Bases: <code>Protocol[K_contra]</code></p> <p>Protocol that represents the deserializer. It is meant to be placed into a Renderer, and is responsible for deserializing the document into embeds and views.</p> <p>             Bases: <code>BaseMessage</code></p> <p>Dataclass that represents the display of the message.</p> <p>Look at https://discordpy.readthedocs.io/en/latest/api.html?highlight=send#discord.abc.Messageable.send</p>"},{"location":"qalib/deserializers/deserializer/#qalib.translators.deserializer.Deserializer.deserialize","title":"<code>deserialize(source, key, callables, events)</code>","text":"<p>This method is used to deserialize a document into an embed and a view.</p> <p>Parameters:</p> <ul> <li> <code>source</code>             (<code>str</code>)         \u2013          <p>document that is deserialized</p> </li> <li> <code>key</code>             (<code>K_contra</code>)         \u2013          <p>key that is used to deserialize the document</p> </li> <li> <code>callables</code>             (<code>Dict[str, Callback]</code>)         \u2013          <p>callables that are used to deserialize the document</p> </li> <li> <code>events</code>             (<code>EventCallbacks</code>)         \u2013          <p>hooks that are called on events</p> </li> </ul> <p>Returns (ReturnType): All possible deserialized types</p>"},{"location":"qalib/deserializers/json/","title":"JSON","text":"<p>             Bases: <code>Deserializer[K_contra]</code></p>"},{"location":"qalib/deserializers/json/#qalib.translators.json.JSONDeserializer.deserialize","title":"<code>deserialize(source, key, callables, events)</code>","text":"<p>Method to deserialize a source into a Display object</p> <p>Parameters:</p> <ul> <li> <code>source</code>             (<code>str</code>)         \u2013          <p>The source text to deserialize</p> </li> <li> <code>key</code>             (<code>K</code>)         \u2013          <p>The key of the element to deserialize</p> </li> <li> <code>callables</code>             (<code>Dict[str, Callback]</code>)         \u2013          <p>A dictionary containing the callables to use for the buttons</p> </li> <li> <code>events</code>             (<code>EventCallbacks</code>)         \u2013          <p>A dictionary containing the event callbacks.</p> </li> </ul> <p>Returns (ReturnType): All possible deserialized objects.</p>"},{"location":"qalib/deserializers/json/#qalib.translators.json.JSONDeserializer.deserialize_element","title":"<code>deserialize_element(document, element, callables, events)</code>","text":"<p>Method to deserialize an element into a Display object</p> <p>Parameters:</p> <ul> <li> <code>document</code>             (<code>Document</code>)         \u2013          <p>The document to deserialize</p> </li> <li> <code>element</code>             (<code>Elements</code>)         \u2013          <p>The element to deserialize</p> </li> <li> <code>callables</code>             (<code>Dict[str, Callback]</code>)         \u2013          <p>A dictionary containing the callables to use for the buttons</p> </li> <li> <code>events</code>             (<code>EventCallbacks</code>)         \u2013          <p>A dictionary containing the event callbacks.</p> </li> </ul> <p>Returns (ReturnType): All possible deserialized objects.</p>"},{"location":"qalib/deserializers/json/#qalib.translators.json.JSONDeserializer.deserialize_expansive","title":"<code>deserialize_expansive(message_tree, callbacks, events)</code>","text":"<p>Method to deserialize a source into a list of Display objects</p> <p>Parameters:</p> <ul> <li> <code>message_tree</code>             (<code>ExpansiveMessage</code>)         \u2013          <p>The ExpansiveMessage of the message_tree</p> </li> <li> <code>callbacks</code>             (<code>Dict[str, Callback]</code>)         \u2013          <p>A dictionary containing the callables to use for the buttons</p> </li> <li> <code>events</code>             (<code>EventCallbacks</code>)         \u2013          <p>A dictionary containing the event callbacks.</p> </li> </ul> <p>Returns (List[Display]): A list of Display objects</p>"},{"location":"qalib/deserializers/json/#qalib.translators.json.JSONDeserializer.deserialize_expansive_into_menu","title":"<code>deserialize_expansive_into_menu(message_tree, callbacks, events)</code>","text":"<p>Method to deserialize an expansive message into a Menu</p> <p>Parameters:</p> <ul> <li> <code>message_tree</code>             (<code>ExpansiveMessage</code>)         \u2013          <p>The ExpansiveMessage of the message_tree</p> </li> <li> <code>callbacks</code>             (<code>Dict[str, Callback]</code>)         \u2013          <p>A dictionary containing the callables to use for the buttons</p> </li> <li> <code>events</code>             (<code>EventCallbacks</code>)         \u2013          <p>A dictionary containing the event callbacks.</p> </li> </ul> <p>Returns (Menu): A Menu object</p>"},{"location":"qalib/deserializers/json/#qalib.translators.json.JSONDeserializer.deserialize_menu","title":"<code>deserialize_menu(menu, callables, events, *, document)</code>","text":"<p>Method to deserialize a menu into a list of Display objects</p> <p>Parameters:</p> <ul> <li> <code>menu</code>             (<code>MenuMessage</code>)         \u2013          <p>The Menu Dictionary to deserialize into a List of Messages</p> </li> <li> <code>callables</code>             (<code>Dict[str, Callback]</code>)         \u2013          <p>A dictionary containing the callables to use for the buttons</p> </li> <li> <code>events</code>             (<code>EventCallbacks</code>)         \u2013          <p>A dictionary containing the event callbacks.</p> </li> <li> <code>document</code>             (<code>Document</code>)         \u2013          <p>the original document containing all the keys.</p> </li> </ul> <p>Returns (List[Message]): A list of Display objects</p>"},{"location":"qalib/deserializers/json/#qalib.translators.json.JSONDeserializer.deserialize_message","title":"<code>deserialize_message(message_tree, callables, events, **overrides)</code>","text":"<p>Method to deserialize an embed into a Display NamedTuple containing the embed and the view</p> <p>Parameters:</p> <ul> <li> <code>message_tree</code>             (<code>Dict[str, Any]</code>)         \u2013          <p>The embed to deserialize</p> </li> <li> <code>callables</code>             (<code>Dict[str, Callback]</code>)         \u2013          <p>A dictionary containing the callables to use for the buttons</p> </li> <li> <code>events</code>             (<code>EventCallbacks</code>)         \u2013          <p>A dictionary containing the event callbacks.</p> </li> <li> <code>**overrides</code>             (<code>Any</code>, default:                 <code>{}</code> )         \u2013          <p>keyword arguments that override the messages</p> </li> </ul> <p>Returns (Display): A Display NamedTuple containing the embed and the view</p>"},{"location":"qalib/deserializers/json/#qalib.translators.json.JSONDeserializer.deserialize_modal","title":"<code>deserialize_modal(tree, callables, events)</code>","text":"<p>Method to deserialize a modal into a discord.ui.Modal object</p> <p>Parameters:</p> <ul> <li> <code>tree</code>             (<code>Modal</code>)         \u2013          <p>The Modal Dictionary to deserialize into a discord.ui.Modal object</p> </li> <li> <code>callables</code>             (<code>Dict[str, Callback]</code>)         \u2013          <p>A dictionary containing the callables to use for the buttons</p> </li> <li> <code>events</code>             (<code>Dict[ModalEvents, ModalEventsCallbacks]</code>)         \u2013          <p>A dictionary containing the event callbacks.</p> </li> </ul> <p>Returns (discord.ui.Modal): A discord.ui.Modal object</p>"},{"location":"qalib/deserializers/json/#qalib.translators.json.JSONDeserializer.deserialize_page","title":"<code>deserialize_page(document, raw_page, callables, events)</code>","text":"<p>Method to deserialize a page into a Display object</p> <p>Parameters:</p> <ul> <li> <code>document</code>             (<code>Document</code>)         \u2013          <p>the original document containing all the keys.</p> </li> <li> <code>raw_page</code>             (<code>Page</code>)         \u2013          <p>The page to deserialize</p> </li> <li> <code>callables</code>             (<code>Dict[str, Callback]</code>)         \u2013          <p>A dictionary containing the callables to use for the buttons</p> </li> <li> <code>events</code>             (<code>EventCallbacks</code>)         \u2013          <p>A dictionary containing the event callbacks.</p> </li> </ul> <p>Returns (List[Message]): List of pages</p>"},{"location":"qalib/deserializers/json/#qalib.translators.json.JSONDeserializer.render_component","title":"<code>render_component(component, callback)</code>","text":"<p>Renders a component from the given component's template</p> <p>Parameters:</p> <ul> <li> <code>component</code>             (<code>Components</code>)         \u2013          <p>the component's template</p> </li> <li> <code>callback</code>             (<code>Optional[Callback]</code>)         \u2013          <p>the callback to be called when the user interacts with the component</p> </li> </ul> <p>Returns (ui.Item): the rendered component</p>"},{"location":"qalib/deserializers/json/#qalib.translators.json.JSONDeserializer.render_components","title":"<code>render_components(raw_components, callables)</code>","text":"<p>Renders the components specified by the identifier</p> <p>Parameters:</p> <ul> <li> <code>raw_components</code>             (<code>Components</code>)         \u2013          <p>the dictionary containing the view component.</p> </li> <li> <code>callables</code>             (<code>Dict[str, Callback]</code>)         \u2013          <p>the callbacks to be called when the user interacts with the components</p> </li> </ul> <p>Returns (List[ui.Item]): the rendered components</p>"},{"location":"qalib/deserializers/json/#working-with-json","title":"Working with JSON","text":"<p>This is the alternative way to use \ud83c\udccf Qalib.You use the keys to the embed as the </p> <p>You can then have multiple embeds which are each contained in a JSON object, and it's key needs to uniquely identifies them among the other embed keys, and is written as <code>{\"test_key\": { ... }, \"test_key2\": { ... }}</code> </p> <p>To render values dynamically, simply put them in between braces, and the renderer will format it when you use the context's <code>rendered_send()</code> method, as seen in the next section. </p> <p>It is safe to skip any non-mandatory fields that an embed would not require, they will simply use their default values.</p>"},{"location":"qalib/deserializers/json/#sample","title":"\ud83e\udde9 Sample","text":"<pre><code>{\n\"test_key\": {\n\"type\": \"message\",\n\"embed\": {\n\"title\": \"Test\",\n\"description\": \"Test Description\",\n\"type\": \"rich\",\n\"colour\": \"55,55,55\",\n\"timestamp\": {\n\"date\": \"{todays_date}\"\n},\n\"url\": \"https://www.discord.com\",\n\"fields\": [\n{\n\"name\": \"Test Field\",\n\"text\": \"Test Text\"\n}\n],\n\"footer\": {\n\"text\": \"Test Footer\",\n\"icon\": \"https://cdn.discordapp.com/embed/avatars/0.png\"\n},\n\"thumbnail\": \"https://cdn.discordapp.com/embed/avatars/0.png\",\n\"image\": \"https://cdn.discordapp.com/embed/avatars/0.png\",\n\"author\": {\n\"name\": \"{author_name}\",\n\"icon\": \"https://cdn.discordapp.com/embed/avatars/0.png\",\n\"url\": \"https://discordapp.com\"\n}\n}\n},\n\"test_key2\": {\n\"type\": \"message\",\n\"embed\": {\n\"title\": \"Test\",\n\"colour\": \"magenta\",\n\"fields\": [\n{\n\"name\": \"Test Field\",\n\"text\": \"Test Text\"\n}\n]\n}\n}\n}\n</code></pre>"},{"location":"qalib/deserializers/json/#views","title":"\ud83d\udd8c\ufe0f Views","text":"<p>The main components are rendered and instantiate the mapped component/item in discord.py. The limit to the number of components/items that you can use in one embed is capped at 25.</p> <p>For each example we will write how the component should look like. Components/Items should be written in the view section, where the comment is.</p> <pre><code>{\n\"test_key2\": {\n\"type\": \"message\",\n\"embed\": {\n\"title\": \"Test2\",\n\"description\": \"Test Description\",\n\"colour\": \"magenta\",\n\"fields\": [\n{\n\"name\": \"Test Field\",\n\"text\": \"Test Text\"\n}\n],\n\"view\": {\n\"components\": []\n}\n}\n}\n}\n</code></pre>"},{"location":"qalib/deserializers/json/#button","title":"\ud83c\udd97 Button","text":"<p>Rendering a Button in <code>.json</code>.</p> <pre><code>\"button_key\": {\n\"type\": \"button\",\n\"label\": \"Click Me!\",\n\"style\": \"success\",\n\"custom_id\": \"{custom_id}\",\n\"disabled\": true,\n\"url\": \"https://github.com/YousefEZ/discord-qalib\",\n\"emoji\": {\n\"name\": \"joy\"\n}\n}\n</code></pre>"},{"location":"qalib/deserializers/json/#select","title":"\ud83c\udff4 Select","text":"<p>Rendering a Select in <code>.json</code> <pre><code>\"select_key\": {\n\"placeholder\": \"Select An Option\",\n\"custom_id\": \"{custom_id}\",\n\"min_values\": 1,\n\"max_values\": 3,\n\"disabled\": false\n\"options\": [\n{\n\"label\": \"Amman\"\n\"value\": 0,\n\"description\": \"The capital city of Jordan\",\n\"emoji\": {\n\"name\": \"Petra\",\n\"id\": 217348923789,\n\"animated\": false\n}\n},\n{\n\"label\": \"Baghdad\"\n},\n{\n\"label\": \"Cairo\"\n},\n{\n\"label\": \"Damascus\"\n}\n]\n}\n</code></pre></p>"},{"location":"qalib/deserializers/json/#channel-select","title":"\ud83d\udce3 Channel Select","text":"<p>Rendering a Channel Select in <code>.json</code> <pre><code>\"channel_key\": {\n\"type\": \"channel_select\",\n\"placeholder\": \"Select A Channel\",\n\"channel_types\": [\"text\", \"private\"],\n\"min_values\": 1,\n\"max_values\": 2,\n\"disabled\": false,\n}\n</code></pre></p>"},{"location":"qalib/deserializers/json/#mentionable-select","title":"\ud83c\udff7\ufe0f Mentionable Select","text":"<p>Rendering a Mentionable Select in <code>.json</code> <pre><code>\"mentionable_key\": {\n\"type\": \"mentionable_select\",\n\"placeholder\": \"Select Something to Mention\",\n\"min_values\": 1,\n\"max_values\": 2,\n\"disabled\": false,\n}\n</code></pre></p>"},{"location":"qalib/deserializers/json/#user-select","title":"\ud83e\udd77 User Select","text":"<p>Rendering a User Select in <code>.json</code></p> <pre><code>\"user_key\": {\n\"type\": \"user_select\",\n\"placeholder\": \"Select A User\",\n\"min_values\": 1,\n\"max_values\": 2,\n\"disabled\": false,\n}\n</code></pre>"},{"location":"qalib/deserializers/json/#role-select","title":"\ud83c\udfad Role Select","text":"<p>Rendering a Role Select in <code>.json</code></p> <pre><code>\"role_key\": {\n\"type\": \"role_select\",\n\"placeholder\": \"Select A Role\",\n\"min_values\": 1,\n\"max_values\": 2,\n\"disabled\": false,\n}\n</code></pre>"},{"location":"qalib/deserializers/json/#text-input","title":"\ud83d\udcac Text Input","text":"<p>Rendering a Text Input in <code>.json</code></p> <pre><code>\"text_select\": {\n\"label\": \"What do you think?\",\n\"style\": \"short\",\n\"placeholder\": \"Write your response...\",\n\"default\": \"N/A\",\n\"min_length\": 0,\n\"max_length\": 150\n}\n</code></pre>"},{"location":"qalib/deserializers/json/#modal","title":"\ud83d\udcdd Modal","text":"<p>Modals can be rendered, simply by using the key to Modal as the key to <code>JSON</code> object. They also need to be passed the methods using their method names as their keys. A Sample document containing Modals can be seen here</p> <pre><code>{\n\"modal1\": {\n\"type\": \"modal\",\n\"title\": \"Modal 1\",\n\"components\": {\n\"name\": {\n\"type\": \"text_input\",\n\"label\": \"What is your name?\",\n\"placeholder\": \"Enter your name\"\n},\n\"age\": {\n\"type\": \"text_input\",\n\"label\": \"What is your age?\",\n\"placeholder\": \"Enter your age\"\n}\n}\n}\n}\n</code></pre>"},{"location":"qalib/deserializers/xml/","title":"XML","text":"<p>             Bases: <code>Deserializer[K_contra]</code></p> <p>Read and process the data given by the XML file, and use given user objects to render the text</p>"},{"location":"qalib/deserializers/xml/#qalib.translators.xml.XMLDeserializer.deserialize","title":"<code>deserialize(source, key, callables, events)</code>","text":"<p>This method is used to deserialize the embed from the XML file.</p> <p>Parameters:</p> <ul> <li> <code>source</code>             (<code>str</code>)         \u2013          <p>raw string containing the element</p> </li> <li> <code>key</code>             (<code>K</code>)         \u2013          <p>key of the element</p> </li> <li> <code>callables</code>             (<code>Dict[str, Callback]</code>)         \u2013          <p>dictionary containing the callables to use for the components</p> </li> <li> <code>events</code>             (<code>EventCallbacks</code>)         \u2013          <p>dictionary containing the events to use for the components</p> </li> </ul> <p>Returns (Message): message containing the embed and its view</p>"},{"location":"qalib/deserializers/xml/#qalib.translators.xml.XMLDeserializer.deserialize_element","title":"<code>deserialize_element(document, element, callables, events)</code>","text":"<p>This method is used to deserialize the embed from the XML file.</p> <p>Parameters:</p> <ul> <li> <code>document</code>             (<code>Element</code>)         \u2013          <p>document containing all the elements</p> </li> <li> <code>element</code>             (<code>Element</code>)         \u2013          <p>element containing the embed</p> </li> <li> <code>callables</code>             (<code>Dict[str, Callback]</code>)         \u2013          <p>dictionary containing the callables to use for the components</p> </li> <li> <code>events</code>             (<code>EventCallbacks</code>)         \u2013          <p>dictionary containing the events to use for the components</p> </li> </ul> <p>Returns (ReturnType): all possible deserialized objects.</p>"},{"location":"qalib/deserializers/xml/#qalib.translators.xml.XMLDeserializer.deserialize_expansive","title":"<code>deserialize_expansive(element, callbacks, events)</code>","text":"<p>Deserializes an embed from an XML file, and returns it as a Display object.</p> <p>Parameters:</p> <ul> <li> <code>element</code>             (<code>Element</code>)         \u2013          <p>templated document contents to deserialize.</p> </li> <li> <code>callbacks</code>             (<code>Dict[str, Callback]</code>)         \u2013          <p>A dictionary containing the callables to use for the components.</p> </li> <li> <code>events</code>             (<code>EventCallbacks</code>)         \u2013          <p>A dictionary containing the events to use for the components.</p> </li> </ul> <p>Returns (List[Message]): A list of messages containing the embed and its view.</p>"},{"location":"qalib/deserializers/xml/#qalib.translators.xml.XMLDeserializer.deserialize_menu","title":"<code>deserialize_menu(element, callables, events, *, document)</code>","text":"<p>Deserializes a menu from an XML file, by generating a list of displays that are connected by buttons in their views to navigate between them.</p> <p>Parameters:</p> <ul> <li> <code>element</code>             (<code>Element</code>)         \u2013          <p>The XML Menu Element to deserialize.</p> </li> <li> <code>callables</code>             (<code>Dict[str, Callback]</code>)         \u2013          <p>A dictionary containing the callables to use for the components.</p> </li> <li> <code>events</code>             (<code>EventCallbacks</code>)         \u2013          <p>A dictionary containing the events to callback on.</p> </li> <li> <code>document</code>             (<code>Element</code>)         \u2013          <p>The entire document</p> </li> </ul> <p>Returns (List[Display]): List of displays that are connected by buttons in their views to navigate between them.</p>"},{"location":"qalib/deserializers/xml/#qalib.translators.xml.XMLDeserializer.deserialize_menu_arrows","title":"<code>deserialize_menu_arrows(arrows_view)</code>","text":"<p>Deserializes the arrows of a menu from an XML file, and returns it as a dictionary.</p> <p>Parameters:</p> <ul> <li> <code>arrows_view</code>             (<code>Element</code>)         \u2013          <p>templated document contents to deserialize.</p> </li> </ul> <p>Returns (Dict[MenuActions, ButtonComponent]): A dictionary containing the arrows.</p>"},{"location":"qalib/deserializers/xml/#qalib.translators.xml.XMLDeserializer.deserialize_message","title":"<code>deserialize_message(message_tree, callables, events, **overrides)</code>","text":"<p>Deserializes an embed from an ElementTree.Element, and returns it as a Display object.</p> <p>Parameters:</p> <ul> <li> <code>message_tree</code>             (<code>Element</code>)         \u2013          <p>The element to deserialize the embed from.</p> </li> <li> <code>callables</code>             (<code>Dict[str, Callback]</code>)         \u2013          <p>A dictionary containing the callables to use for the components.</p> </li> <li> <code>events</code>             (<code>EventCallbacks</code>)         \u2013          <p>A dictionary containing the events to use for the components.</p> </li> <li> <code>**overrides</code>             (<code>Any</code>, default:                 <code>{}</code> )         \u2013          <p>any overrides to apply to the Message</p> </li> </ul> <p>Returns (Message): A display object containing the embed and its view.</p>"},{"location":"qalib/deserializers/xml/#qalib.translators.xml.XMLDeserializer.deserialize_modal","title":"<code>deserialize_modal(element, callables, events)</code>","text":"<p>Method to deserialize a modal into a discord.ui.Modal object</p> <p>Parameters:</p> <ul> <li> <code>element</code>             (<code>Element</code>)         \u2013          <p>The element to deserialize into a modal</p> </li> <li> <code>callables</code>             (<code>Dict[str, Callback]</code>)         \u2013          <p>A dictionary containing the callables to use for the components</p> </li> <li> <code>events</code>             (<code>Dict[ModalEvents, ModalEventsCallbacks]</code>)         \u2013          <p>A dictionary containing the events to callback on</p> </li> </ul> <p>Returns (discord.ui.Modal): A discord.ui.Modal object</p>"},{"location":"qalib/deserializers/xml/#qalib.translators.xml.XMLDeserializer.get_attribute","title":"<code>get_attribute(element, attribute)</code>  <code>staticmethod</code>","text":"<p>Renders an attribute from an ElementTree.Element.</p> <p>Parameters:</p> <ul> <li> <code>element</code>             (<code>Element</code>)         \u2013          <p>The element to render the attribute from.</p> </li> <li> <code>attribute</code>             (<code>str</code>)         \u2013          <p>The name of the attribute to render.</p> </li> </ul> <p>Returns (str): The value of the attribute.</p>"},{"location":"qalib/deserializers/xml/#qalib.translators.xml.XMLDeserializer.get_element_text","title":"<code>get_element_text(element)</code>  <code>staticmethod</code>","text":"<p>Renders the given ElementTree.Element by returning its text.</p> <p>Parameters:</p> <ul> <li> <code>element</code>             (<code>Element</code>)         \u2013          <p>The element to render.</p> </li> </ul> <p>Returns (str): The rendered element.</p>"},{"location":"qalib/deserializers/xml/#qalib.translators.xml.XMLDeserializer.pop_component","title":"<code>pop_component(component, key)</code>  <code>staticmethod</code>","text":"<p>Pops a component from the given element, and returns it.</p> <p>Parameters:</p> <ul> <li> <code>component</code>             (<code>Element</code>)         \u2013          <p>The element to pop the component from.</p> </li> <li> <code>key</code>             (<code>str</code>)         \u2013          <p>The key of the component to pop.</p> </li> </ul> <p>Returns (Optional[ElementTree.Element]): The popped component, or None if it doesn't exist.</p>"},{"location":"qalib/deserializers/xml/#qalib.translators.xml.XMLDeserializer.render_component","title":"<code>render_component(component, callback)</code>","text":"<p>Renders a component based on the tag in the element.</p> <p>Parameters:</p> <ul> <li> <code>component</code>             (<code>Element</code>)         \u2013          <p>The component to render, contains all template.</p> </li> <li> <code>callback</code>             (<code>Optional[Callback]</code>)         \u2013          <p>The callback to use if the user interacts with this component.</p> </li> </ul> <p>Returns (discord.ui.Item): The rendered component.</p>"},{"location":"qalib/deserializers/xml/#qalib.translators.xml.XMLDeserializer.render_components","title":"<code>render_components(view, callables)</code>","text":"<p>Renders a list of components based on the identifier given.</p> <p>Parameters:</p> <ul> <li> <code>view</code>             (<code>View</code>)         \u2013          <p>The raw view.</p> </li> <li> <code>callables</code>             (<code>Dict[str, Callback]</code>)         \u2013          <p>The callbacks to use if the user interacts with the components.</p> </li> </ul> <p>Returns (Optional[List[discord.ui.Item]]): The rendered components.</p>"},{"location":"qalib/deserializers/xml/#working-with-xml","title":"Working with XML","text":"<p>This is the main way to use \ud83c\udccf Qalib. You must have a <code>&lt;discord&gt;</code> tag that spans the entire document, as it is treated as the root of the ElementTree.</p> <p>You can then have multiple embeds which are each contained in a <code>&lt;embed&gt;</code> tag, and must have a <code>key</code> attribute that uniquely identifies them among the other embed keys, and is written as <code>&lt;embed key=\"key_name\"&gt;</code>. </p> <p>To render values dynamically, simply put them in between braces, and the renderer will format it when you use the context's <code>rendered_send()</code> method, as seen in the next section. </p> <p>It is safe to skip any non-mandatory fields that an embed would not require, they will simply use their default values.</p>"},{"location":"qalib/deserializers/xml/#sample","title":"\ud83e\udde9 Sample","text":"<p><pre><code>&lt;discord&gt;\n&lt;embed key=\"test_key\"&gt;\n&lt;title&gt;Test Title&lt;/title&gt;\n&lt;description&gt;Test Description&lt;/description&gt;\n&lt;type&gt;rich&lt;/type&gt;\n&lt;colour&gt;magenta&lt;/colour&gt;\n&lt;timestamp format=\"%d-%m%-Y\"&gt;22-04-2023&lt;/timestamp&gt;\n&lt;url&gt;https://www.discord.com&lt;/url&gt;\n&lt;fields&gt;\n&lt;field&gt;\n&lt;name&gt;Test Field&lt;/name&gt;\n&lt;text&gt;Test Text&lt;/text&gt;\n&lt;/field&gt;\n&lt;/fields&gt;\n&lt;footer&gt;\n&lt;text&gt;Test Footer&lt;/text&gt;\n&lt;icon&gt;https://cdn.discordapp.com/embed/avatars/0.png&lt;/icon&gt;\n&lt;/footer&gt;\n&lt;thumbnail&gt;https://cdn.discordapp.com/embed/avatars/0.png&lt;/thumbnail&gt;\n&lt;image&gt;https://cdn.discordapp.com/embed/avatars/0.png&lt;/image&gt;\n&lt;author&gt;\n&lt;name&gt;{author_name}&lt;/name&gt;\n&lt;icon&gt;https://cdn.discordapp.com/embed/avatars/0.png&lt;/icon&gt;\n&lt;url&gt;https://discordapp.com&lt;/url&gt;\n&lt;/author&gt;\n&lt;/embed&gt;\n&lt;embed key=\"test_key2\"&gt;\n&lt;title&gt;Test&lt;/title&gt;\n&lt;colour&gt;magenta&lt;/colour&gt;\n&lt;fields&gt;\n&lt;field&gt;\n&lt;name&gt;Test Field&lt;/name&gt;\n&lt;text&gt;Test Text&lt;/text&gt;\n&lt;/field&gt;\n&lt;/fields&gt;\n&lt;/embed&gt;\n&lt;/discord&gt;\n</code></pre> For the purpose of this example, we store this file in <code>templates/test.xml</code></p>"},{"location":"qalib/deserializers/xml/#views","title":"\ud83d\udd8c\ufe0f Views","text":"<p>The main components are rendered and instantiate the mapped component/item in discord.py. The limit to the number of components/items that you can use in one embed is capped at 25.</p> <p>For each example we will write how the component should look like. Components/Items should be written in the view section, where the comment is. <pre><code>&lt;discord&gt;\n&lt;message key=\"test\"&gt;\n&lt;embed&gt;\n&lt;title&gt;This is a Test!&lt;/title&gt;\n&lt;colour&gt;cyan&lt;/colour&gt;\n&lt;fields&gt;\n&lt;field&gt;\n&lt;name&gt;Test Field&lt;/name&gt;\n&lt;value&gt;Test Value&lt;/value&gt;\n&lt;/field&gt;\n&lt;/fields&gt;\n&lt;view&gt;\n&lt;components&gt;\n&lt;!--Each component/item should go here--&gt;\n&lt;/components&gt;\n&lt;/view&gt;\n&lt;/embed&gt;\n&lt;/message&gt;\n&lt;/discord&gt;\n</code></pre></p>"},{"location":"qalib/deserializers/xml/#button","title":"\ud83c\udd97 Button","text":"<p>Rendering a Button in <code>.xml</code>.</p> <pre><code>&lt;button key=\"click_key\"&gt;\n&lt;label&gt;Click Me!&lt;/label&gt;\n&lt;style&gt;success&lt;/style&gt;\n&lt;custom_id&gt;{custom_id}&lt;/style&gt;\n&lt;disabled&gt;false&lt;/disabled&gt;\n&lt;url&gt;https://github.com/YousefEZ/discord-qalib&lt;/url&gt;\n&lt;emoji&gt;\n&lt;name&gt;joy&lt;/name&gt;\n&lt;/emoji&gt;\n&lt;/button&gt;\n</code></pre>"},{"location":"qalib/deserializers/xml/#select","title":"\ud83c\udff4 Select","text":"<p>Rendering a Select in <code>.xml</code> <pre><code>&lt;select key=\"select_key\"&gt;\n&lt;placeholder&gt;Select An Option&lt;/placeholder&gt;\n&lt;custom_id&gt;{custom_id}&lt;/custom_id&gt;\n&lt;min_values&gt;1&lt;/min_values&gt;\n&lt;max_values&gt;3&lt;/max_values&gt;\n&lt;disabled&gt;false&lt;/disabled&gt;\n&lt;options&gt;\n&lt;option&gt;\n&lt;label&gt;Amman&lt;/label&gt;\n&lt;value&gt;0&lt;/value&gt;\n&lt;description&gt;The Capital of Jordan&lt;/description&gt;\n&lt;emoji&gt;\n&lt;name&gt;Petra&lt;/name&gt;\n&lt;id&gt;217348923789&lt;/id&gt;\n&lt;animated&gt;false&lt;/false&gt;\n&lt;/emoji&gt;\n&lt;/option&gt;\n&lt;option&gt;\n&lt;label&gt;Baghdad&lt;/label&gt;\n&lt;/option&gt;\n&lt;option&gt;\n&lt;label&gt;Cairo&lt;/label&gt;\n&lt;/option&gt;\n&lt;option&gt;\n&lt;label&gt;Damascus&lt;/label&gt;\n&lt;/option&gt;\n&lt;/options&gt;\n&lt;/select&gt;\n</code></pre></p>"},{"location":"qalib/deserializers/xml/#channel-select","title":"\ud83d\udce3 Channel Select","text":"<p>Rendering a Channel Select in <code>.xml</code> <pre><code>&lt;channel_select key=\"channel_select_key\"&gt;\n&lt;placeholder&gt;Select a Channel&lt;/channel_type&gt;\n&lt;channel_types&gt;\n&lt;channel_type&gt;text&lt;/channel_type&gt;\n&lt;channel_type&gt;voice&lt;/channel_type&gt;\n&lt;/channel_types&gt;\n&lt;min_values&gt;1&lt;/min_values&gt;\n&lt;max_values&gt;5&lt;/max_values&gt;\n&lt;disabled&gt;false&lt;/disabled&gt;\n&lt;/channel_select&gt;\n</code></pre></p>"},{"location":"qalib/deserializers/xml/#mentionable-select","title":"\ud83c\udff7\ufe0f Mentionable Select","text":"<p>Rendering a Mentionable Select in <code>.xml</code> <pre><code>&lt;mentionable_select key=\"mentionable_key\"&gt;\n&lt;placeholder&gt;Select Something to Mention&lt;/placeholder&gt;\n&lt;min_values&gt;1&lt;/min_values&gt;\n&lt;max_values&gt;2&lt;/max_values&gt;\n&lt;disabled&gt;false&lt;/disabled&gt;\n&lt;/mentionable_select&gt;\n</code></pre></p>"},{"location":"qalib/deserializers/xml/#user-select","title":"\ud83e\udd77 User Select","text":"<p>Rendering a User Select in <code>.xml</code></p> <pre><code>&lt;user_select key=\"user_key\"&gt;\n&lt;placeholder&gt;Select a User&lt;/placeholder&gt;\n&lt;min_values&gt;1&lt;/min_values&gt;\n&lt;max_values&gt;2&lt;/max_values&gt;\n&lt;disabled&gt;false&lt;/disabled&gt;\n&lt;/user_select&gt;\n</code></pre>"},{"location":"qalib/deserializers/xml/#role-select","title":"\ud83c\udfad Role Select","text":"<p>Rendering a Role Select in <code>.xml</code></p> <pre><code>&lt;role_select key=\"role_select_key\"&gt;\n&lt;placeholder&gt;Select a Role&lt;/placeholder&gt;\n&lt;min_values&gt;1&lt;/min_values&gt;\n&lt;max_values&gt;2&lt;/max_values&gt;\n&lt;disabled&gt;false&lt;/disabled&gt;\n&lt;/role_select&gt;\n</code></pre>"},{"location":"qalib/deserializers/xml/#text-input","title":"\ud83d\udcac Text Input","text":"<p>Rendering a Text Input in <code>.xml</code></p> <pre><code>&lt;text_input key=\"text_input_key\"&gt;\n&lt;label&gt;What do you think?&lt;/label&gt;\n&lt;style&gt;short&lt;/style&gt;\n&lt;placeholder&gt;Write your response...&lt;/placeholder&gt;\n&lt;default&gt;N/A&lt;/default&gt;\n&lt;min_length&gt;0&lt;/min_length&gt;\n&lt;max_length&gt;150&lt;/max_length&gt;\n&lt;/text_input&gt;\n</code></pre>"},{"location":"qalib/deserializers/xml/#modals","title":"\ud83d\udcdd Modals","text":"<p>Modals can be rendered by using the <code>&lt;modal&gt;</code>. They also need to be passed the methods using their method names as their keys. A Sample document containing Modals can be seen here</p> <pre><code>&lt;discord&gt;\n&lt;modal key=\"modal1\" title=\"Questionnaire\"&gt;\n&lt;text_input&gt;\n&lt;label&gt;What is your name?&lt;/label&gt;\n&lt;placeholder&gt;Enter your name&lt;/placeholder&gt;\n&lt;style&gt;long&lt;/style&gt;\n&lt;/text_input&gt;\n&lt;text_input&gt;\n&lt;label&gt;What is your age?&lt;/label&gt;\n&lt;placeholder&gt;Enter your age&lt;/placeholder&gt;\n&lt;style&gt;long&lt;/style&gt;\n&lt;/text_input&gt;\n&lt;/modal&gt;\n&lt;/discord&gt;\n</code></pre>"},{"location":"qalib/template_engines/formatter/","title":"Formatter","text":"<p>             Bases: <code>TemplateEngine</code></p>"},{"location":"qalib/template_engines/formatter/#qalib.template_engines.formatter.Formatter.template","title":"<code>template(document, keywords)</code>","text":"<p>This method is used to format a string using the format method.</p> <p>Parameters:</p> <ul> <li> <code>document</code>             (<code>str</code>)         \u2013          <p>string that is formatted</p> </li> <li> <code>keywords</code>             (<code>Dict[str, Any]</code>)         \u2013          <p>keywords that are used to format the string</p> </li> </ul> <p>Returns (str): formatted string</p>"},{"location":"qalib/template_engines/jinja2/","title":"Jinja2","text":"<p>             Bases: <code>TemplateEngine</code></p>"},{"location":"qalib/template_engines/jinja2/#qalib.template_engines.jinja2.Jinja2.environment","title":"<code>environment: Environment</code>  <code>property</code>","text":"<p>This property is used to get the environment of the template engine.</p> <p>Returns (Environment): environment of the template engine</p>"},{"location":"qalib/template_engines/jinja2/#qalib.template_engines.jinja2.Jinja2.template","title":"<code>template(document, keywords)</code>","text":"<p>This method is used to format a string using the format method.</p> <p>Parameters:</p> <ul> <li> <code>document</code>             (<code>str</code>)         \u2013          <p>string that is formatted</p> </li> <li> <code>keywords</code>             (<code>Dict[str, Any]</code>)         \u2013          <p>keywords that are used to format the string</p> </li> </ul> <p>Returns (str): formatted string</p>"},{"location":"qalib/templaters/json/","title":"JSON","text":"<p>             Bases: <code>Templater</code></p> <p>This method is used to parse the document into a menu and a list of callables for .json files</p>"},{"location":"qalib/templaters/json/#qalib.translators.json.JSONTemplater.__init__","title":"<code>__init__(source)</code>","text":"<p>This method is used to initialize the parser by parsing the source text.</p> <p>Parameters:</p> <ul> <li> <code>source</code>             (<code>str</code>)         \u2013          <p>source text that is parsed</p> </li> </ul>"},{"location":"qalib/templaters/json/#qalib.translators.json.JSONTemplater.recursive_template","title":"<code>recursive_template(obj, template_engine, keywords)</code>","text":"<p>Method that is used to recursively template the object using the templater and the keywords.</p> <p>Parameters:</p> <ul> <li> <code>obj</code>             (<code>Dict | List | str | Any</code>)         \u2013          <p>object that is templated</p> </li> <li> <code>template_engine</code>             (<code>TemplateEngine</code>)         \u2013          <p>template engine that is used to template the object</p> </li> <li> <code>keywords</code>             (<code>Dict[str, Any]</code>)         \u2013          <p>keywords that are used to template the object</p> </li> </ul> <p>Returns (Dict[str, Any]): templated object</p>"},{"location":"qalib/templaters/json/#qalib.translators.json.JSONTemplater.template","title":"<code>template(template_engine, keywords)</code>","text":"<p>This method is used to template the element by first retrieving it using its key, and then templating it using the template_engine</p> <p>Parameters:</p> <ul> <li> <code>template_engine</code>             (<code>TemplateEngine</code>)         \u2013          <p>template engine that is used to template the element</p> </li> <li> <code>keywords</code>             (<code>Dict[str, Any]</code>)         \u2013          <p>keywords that are used to template the element</p> </li> </ul> <p>Returns (str): templated element in the form of string.</p>"},{"location":"qalib/templaters/templater/","title":"Templater","text":"<p>             Bases: <code>Protocol</code></p> <p>Protocol that represents the parser. It is meant to be placed into a Renderer, and is responsible for parsing the document into a menu and a list of callables.</p>"},{"location":"qalib/templaters/templater/#qalib.translators.templater.Templater.__init__","title":"<code>__init__(source)</code>","text":"<p>This method is used to initialize the parser by parsing the source text.</p> <p>Parameters:</p> <ul> <li> <code>source</code>             (<code>str</code>)         \u2013          <p>source text that is parsed</p> </li> </ul>"},{"location":"qalib/templaters/templater/#qalib.translators.templater.Templater.template","title":"<code>template(template_engine, keywords)</code>","text":"<p>This method is used to template the embed by first retrieving it using its key, and then templating it using the template_engine</p> <p>Parameters:</p> <ul> <li> <code>template_engine</code>             (<code>TemplateEngine</code>)         \u2013          <p>template engine that is used to template the embed</p> </li> <li> <code>keywords</code>             (<code>Dict[str, Any]</code>)         \u2013          <p>keywords that are used to template the embed</p> </li> </ul> <p>Returns (str): templated embed in the form of string.</p>"},{"location":"qalib/templaters/xml/","title":"XML","text":"<p>             Bases: <code>Templater</code></p>"},{"location":"qalib/templaters/xml/#qalib.translators.xml.XMLTemplater.__init__","title":"<code>__init__(source)</code>","text":"<p>Initialisation of the XML Parser</p> <p>Parameters:</p> <ul> <li> <code>source</code>             (<code>str</code>)         \u2013          <p>the text of the XML file</p> </li> </ul>"},{"location":"qalib/templaters/xml/#qalib.translators.xml.XMLTemplater.template","title":"<code>template(template_engine, keywords)</code>","text":"<p>This method is used to template an element, by identifying it by its key and using the template engine to template it.</p> <p>Parameters:</p> <ul> <li> <code>template_engine</code>             (<code>TemplateEngine</code>)         \u2013          <p>template engine that is used to template the embed</p> </li> <li> <code>keywords</code>             (<code>Dict[str, Any]</code>)         \u2013          <p>keywords that are used to template the embed</p> </li> </ul> <p>Returns (str): templated embed</p>"},{"location":"usage/installation/","title":"Installation","text":"<p>To install this simply run:</p> <pre><code>pip install discord-qalib\n</code></pre> <p>To test this is working simply open an interactive shell and run:</p> <pre><code>import qalib\nprint(qalib.__version__)\n</code></pre> <pre><code>&gt;&gt;&gt; 2.5.2\n</code></pre>"},{"location":"usage/simple-usage/","title":"Usage","text":"<p>Here we will be talking about how to use the interface of the QalibContext</p>"},{"location":"usage/simple-usage/#basic-usage","title":"Basic Usage","text":"<p>This is a simple XML file that contains a barebones embed</p> <pre><code>&lt;discord&gt;\n&lt;message key=\"test_key\"&gt;\n&lt;embed&gt;\n&lt;title&gt;Hello World&lt;/title&gt;\n&lt;colour&gt;cyan&lt;/colour&gt;\n&lt;fields&gt;\n&lt;field&gt;\n&lt;name&gt;Field 1&lt;/name&gt;\n&lt;value&gt;The first field is mandatory&lt;/value&gt;\n&lt;/field&gt;\n&lt;/fields&gt;\n&lt;/embed&gt;\n&lt;/message&gt;\n&lt;/discord&gt;\n</code></pre> <p>Lets dissect this, piece by piece. First off, we have the <code>&lt;discord&gt;</code> tag which is the container (ElementTree) for all the <code>&lt;message&gt;</code> and <code>&lt;menu&gt;</code> elements. We can have a variable number of <code>&lt;message&gt;</code> and <code>&lt;menu&gt;</code> elements and they are uniquely identified by their <code>key</code> attribute such as <code>&lt;message key=\"test_key\"&gt;</code> or <code>&lt;menu key=\"test_key2\"&gt;</code>, which is used to identify this embed, in this case <code>test_key</code> uniquely identifies the message, and <code>test_key2</code> uniquely identifies the menu.</p> <p>In the menu element, we have <code>&lt;message&gt;</code> tags which uniquely identify the messages that are associated with the menu.</p> <p>The <code>&lt;message&gt;</code> tag has a <code>key</code> attribute which is used to identify the message, and various tags. You can use the <code>&lt;embed&gt;</code> tag to create a custom embed that is attached to the message as seen above.</p> <p>There are other tags that allow you to control how the message is used, such as the <code>&lt;tts&gt;true&lt;/tts&gt;</code> tag which is a boolean value that determines whether the message is sent as text-to-speech or not, and the <code>&lt;delete_after&gt;15.0&lt;/delete_after&gt;</code> tag which is a float value that deletes the message after the specified number of seconds. The full list can be seen here</p>"},{"location":"usage/simple-usage/#components-of-embed-tag","title":"Components of Embed Tag","text":"<p>We then use the the components of the embed tag, so the 3 mandatory elements of an embed that is required to render it is the <code>&lt;title&gt;</code>, <code>&lt;colour&gt;</code>/<code>&lt;color&gt;</code>, and at least one <code>&lt;field&gt;</code> in the <code>&lt;fields&gt;</code> container, which contain a <code>&lt;name&gt;</code>, and a <code>&lt;value&gt;</code>.</p> <p>Using more of the attributes that can associated with an embed</p> <p>Each embed can be extended to leverage more the things that an embed can offer such as:</p> <ol> <li>Description</li> <li>Type</li> <li>Timestamp (with format attribute defaulting to \"%Y-%m-%d %H:%M:%S.%f\")</li> <li>Url</li> <li>Footer</li> <ol> <li>Text</li> <li>Icon</li> </ol> <li>Thumbnail</li> <li>Image</li> <li>Author</li> <ol> <li>Name</li> <li>Icon</li> <li>Url</li> </ol> </ol> <p>You can view how to write them in different file formats, such as xml and json</p> <p>So an example of fully using all the features an embed could offer is as such:</p> <pre><code>&lt;discord&gt;\n&lt;message key=\"test_key\"&gt;\n&lt;embed&gt;\n&lt;title&gt;Test&lt;/title&gt;\n&lt;description&gt;Test Description&lt;/description&gt;\n&lt;type&gt;rich&lt;/type&gt;\n&lt;colour&gt;magenta&lt;/colour&gt;\n&lt;timestamp format=\"%d-%m%-Y\"&gt;22-04-2023&lt;/timestamp&gt;\n&lt;url&gt;https://www.discord.com&lt;/url&gt;\n&lt;fields&gt;\n&lt;field&gt;\n&lt;name&gt;Test Field&lt;/name&gt;\n&lt;text&gt;Test Text&lt;/text&gt;\n&lt;/field&gt;\n&lt;/fields&gt;\n&lt;footer&gt;\n&lt;text&gt;Test Footer&lt;/text&gt;\n&lt;icon&gt;https://cdn.discordapp.com/embed/avatars/0.png&lt;/icon&gt;\n&lt;/footer&gt;\n&lt;thumbnail&gt;https://cdn.discordapp.com/embed/avatars/0.png&lt;/thumbnail&gt;\n&lt;image&gt;https://cdn.discordapp.com/embed/avatars/0.png&lt;/image&gt;\n&lt;author&gt;\n&lt;name&gt;Test Author&lt;/name&gt;\n&lt;icon&gt;https://cdn.discordapp.com/embed/avatars/0.png&lt;/icon&gt;\n&lt;url&gt;https://discordapp.com&lt;/url&gt;\n&lt;/author&gt;\n&lt;/embed&gt;\n&lt;/message&gt;\n&lt;/discord&gt;\n</code></pre>"},{"location":"usage/simple-usage/#rendering-values","title":"Rendering Values","text":"<p>You can choose your <code>TemplateEngine</code>. The ones that are currently defined is <code>Formatter</code> which uses python's format method, and the <code>Jinja2</code> template engine, which is an adapter over Jinja2. The <code>TemplateEngine</code> is used in the form of a Dependency Injection into the <code>Renderer</code> instance via its constructor. The <code>Renderer</code> templates and deserializes the files into a <code>Display</code>. The <code>Renderer</code> instance is injected into the <code>QalibContext</code> which extends the <code>discord.ext.commands.Context</code>.</p> <p>You can use the <code>qalib_context</code> decorator over a <code>bot.command</code> so that it overrides the <code>discord.ext.commands.Context</code> with its subclass <code>QalibContext</code>.</p> <pre><code>&lt;discord&gt;\n&lt;message key=\"bank\"&gt;\n&lt;embed&gt;\n&lt;title&gt;Balance {player.name}&lt;/title&gt;\n&lt;colour&gt;cyan&lt;/colour&gt;\n&lt;fields&gt;\n&lt;field&gt;\n&lt;name&gt;{player.bank_name}&lt;/name&gt;\n&lt;value&gt;Has \ud83d\udcb5{player.funds} EGP in the bank&lt;/value&gt;\n&lt;/field&gt;\n&lt;/fields&gt;\n&lt;/embed&gt;\n&lt;/message&gt;\n&lt;/discord&gt;\n</code></pre>"},{"location":"usage/simple-usage/#qalibcontext","title":"QalibContext","text":"<p>so if we have this sample file called <code>player.xml</code> that is in the <code>templates/</code> directory:</p> <pre><code>&lt;discord&gt;\n&lt;message key=\"army\"&gt;\n&lt;embed&gt;\n&lt;title&gt;Army of {player.name}&lt;/title&gt;\n&lt;colour&gt;cyan&lt;/colour&gt;\n&lt;fields&gt;\n&lt;field&gt;\n&lt;name&gt;{player.army_name}&lt;/name&gt;\n&lt;value&gt;Has \ud83d\udc82{player.soldiers} defending the nation&lt;/value&gt;\n&lt;/field&gt;\n&lt;/fields&gt;\n&lt;/embed&gt;\n&lt;/message&gt;\n&lt;message key=\"bank\"&gt;\n&lt;embed&gt;\n&lt;title&gt;Hello {player.name}&lt;/title&gt;\n&lt;colour&gt;cyan&lt;/colour&gt;\n&lt;fields&gt;\n&lt;field&gt;\n&lt;name&gt;{player.bank_name}&lt;/name&gt;\n&lt;value&gt;Has \ud83d\udcb5{player.funds} EGP in the bank&lt;/value&gt;\n&lt;/field&gt;\n&lt;/fields&gt;\n&lt;/embed&gt;\n&lt;/message&gt;\n&lt;/discord&gt;\n</code></pre> <p>the <code>Renderer</code> class uses it to render the template, and form a message that can be sent using the QalibContext instance.</p> <pre><code>from dataclasses import dataclass\nfrom typing import Literal\nimport discord\nfrom discord.ext import commands\nimport qalib\nfrom qalib.template_engines.formatter import Formatter\nbot = commands.AutoShardedBot(command_prefix=\"!\", intents=discord.Intents.all())\nMessages = Literal[\"army\", \"bank\"]\n@dataclass\nclass Player:\nname: str\nbank: str\nfunds: float\narmy_name: str\nsoldiers: int\ndef fetch_player(name: str) -&gt; Player:\n...\n@bot.command()\n@qalib.qalib_context(Formatter(), \"templates/player.xml\")\nasync def test(ctx: qalib.QalibContext[Messages], name: str):\nawait ctx.rendered_send(\"army\", keywords={\n\"player\": fetch_player(name)\n})\n</code></pre>"},{"location":"usage/simple-usage/#qalibinteraction","title":"QalibInteraction","text":"<p>There is also a <code>QalibInteraction</code>, so that it extends the <code>discord.Interaction</code> instance. Using the same <code>.xml</code> file as the previous section we are able to use the <code>QalibInteraction</code> with a slash command as such:</p> <pre><code>from dataclasses import dataclass\nfrom typing import Literal\nimport discord\nfrom discord.ext import commands\nimport qalib\nfrom qalib.template_engines.formatter import Formatter\nbot = commands.AutoShardedBot(command_prefix=\"!\", intents=discord.Intents.all())\nMessages = Literal[\"army\", \"bank\"]\n@dataclass\nclass Player:\nname: str\nbank: str\nfunds: float\narmy_name: str\nsoldiers: int\ndef fetch_player(name: str) -&gt; Player:\n...\n@bot.tree.command(name=\"test\")\n@discord.app_commands.describe(player_name=\"What is the name of the player?\")\n@qalib.qalib_interaction(Formatter(), \"templates/player.xml\")\nasync def test(interaction: qalib.QalibInteraction[Messages], player_name: str):\nawait interaction.rendered_send(\"army\", keywords={\n\"player\": fetch_player(player_name)\n})\n@bot.event\nasync def on_ready():\nawait bot.tree.sync()\n</code></pre>"},{"location":"usage/simple-usage/#modals","title":"Modals","text":"<p><code>QalibInteractions</code> are also able to render Modals from their documents using the <code>.render(key, callables, keywords, events)</code> method. With the events allowing you to respond to user actions</p> <ul> <li><code>ModalEvents.ON_TIMEOUT</code>: when the view times out.</li> </ul> <pre><code>import qalib.translators.json.components\nimport qalib.translators.json\nasync def on_timeout(view: qalib.translators.json.components.Modal) -&gt; None:\n...\n</code></pre> <ul> <li><code>ModalEvents.ON_CHECK</code>: when the view is being interacted with, have a check to return a bool to call any callbacks</li> </ul> <pre><code>import qalib.translators.json.components\nimport qalib.translators.json\nasync def check(view: qalib.translators.json.components.Modal, interaction: discord.Interaction) -&gt; bool:\n...\n</code></pre> <ul> <li><code>ModalEvents.ON_ERROR</code>: when the view throws out an exception, this event is called</li> </ul> <pre><code>import qalib.translators.json.components\nimport qalib.translators.json\nasync def error_handling(\nview: qalib.translators.json.components.Modal,\ninteraction: discord.Interaction,\nerror: Exception\n) -&gt; None:\n...\n</code></pre> <ul> <li><code>ModalEvents.ON_SUBMIT</code>: when the modal is submitted this event is called</li> </ul> <pre><code>import qalib.translators.json.components\nimport qalib.translators.json\nasync def submit(view: qalib.translators.json.components.Modal, interaction: discord.Interaction) -&gt; None:\n...\n</code></pre> <p>You can also attach the callables to the button using the dictionary in the callables keyword in the <code>.rendered_send</code> method, and the dictionary in the events keywords</p> <pre><code>&lt;discord&gt;\n&lt;modal key=\"modal1\" title=\"Questionnaire\"&gt;\n&lt;timeout/&gt;\n&lt;components&gt;\n&lt;text_input&gt;\n&lt;label&gt;What is your name?&lt;/label&gt;\n&lt;placeholder&gt;Enter your name&lt;/placeholder&gt;\n&lt;style&gt;long&lt;/style&gt;\n&lt;/text_input&gt;\n&lt;text_input&gt;\n&lt;label&gt;What is your age?&lt;/label&gt;\n&lt;placeholder&gt;Enter your age&lt;/placeholder&gt;\n&lt;style&gt;long&lt;/style&gt;\n&lt;/text_input&gt;\n&lt;/components&gt;\n&lt;/modal&gt;\n&lt;/discord&gt;\n</code></pre> <pre><code>from typing import Literal\nimport discord\nfrom discord.ext import commands\nimport qalib\nfrom qalib.template_engines.formatter import Formatter\nfrom qalib.translators.modal import ModalEvents\nbot = commands.AutoShardedBot(command_prefix=\"!\", intents=discord.Intents.all())\nMessages = Literal[\"welcome\"]\n@bot.command()\n@qalib.qalib_context(Formatter(), \"templates/button.xml\")\nasync def greet(ctx: qalib.QalibContext[Messages]):\nasync def on_submit(view: discord.ui.View, interaction: discord.Interaction):\n...\nawait ctx.rendered_send(\"modal1\", events={ModalEvents.ON_SUBMIT: on_submit})\n</code></pre>"},{"location":"usage/simple-usage/#using-views","title":"Using Views","text":"<p>We also support the rendering of views, and the different UI Components for each embed.</p> <pre><code>&lt;discord&gt;\n&lt;message key=\"welcome\"&gt;\n&lt;embed&gt;\n&lt;title&gt;Greet&lt;/title&gt;\n&lt;colour&gt;cyan&lt;/colour&gt;\n&lt;fields&gt;\n&lt;field&gt;\n&lt;name&gt;Hello!&lt;/name&gt;\n&lt;value&gt;Welcome!&lt;/value&gt;\n&lt;/field&gt;\n&lt;/fields&gt;\n&lt;view&gt;\n&lt;components&gt;\n&lt;button key=\"greet\"&gt;\n&lt;label&gt;Click Me!&lt;/label&gt;\n&lt;style&gt;success&lt;/style&gt;\n&lt;/button&gt;\n&lt;/components&gt;\n&lt;/view&gt;\n&lt;/embed&gt;\n&lt;/message&gt;\n&lt;/discord&gt;\n</code></pre> <p>This is stored as <code>templates/button.xml</code></p> <p>There are other components that can be rendered, and is shown in the XML View Section</p> <p>You can hook into the events of the components by passing a dictionary of events to the <code>.rendered_send</code> method,</p> <p>there are multiple events that can be triggered,</p> <p>Views:</p> <ul> <li><code>ViewEvents.ON_TIMEOUT</code>: when the view times out.</li> </ul> <pre><code>import qalib.translators.json.components\nimport qalib.translators.json\nasync def on_timeout(view: qalib.translators.json.components.View) -&gt; None:\n...\n</code></pre> <ul> <li><code>ViewEvents.ON_CHECK</code>: when the view is being interacted with, have a check to return a bool to call any callbacks</li> </ul> <pre><code>import qalib.translators.json.components\nimport qalib.translators.json\nasync def check(view: qalib.translators.json.components.View, interaction: discord.Interaction) -&gt; bool:\n...\n</code></pre> <ul> <li><code>ViewEvents.ON_ERROR</code>: when the view throws out an exception, this event is called</li> </ul> <pre><code>import qalib.translators.json.components\nimport qalib.translators.json\nasync def error_handling(\nview: qalib.translators.json.components.View,\ninteraction: discord.Interaction,\nerror: Exception,\nitem: discord.ui.Item\n) -&gt; None:\n...\n</code></pre> <p>You can also attach the callables to the button using the dictionary in the callables keyword in the <code>.rendered_send</code> method, and the dictionary in the events keywords</p> <pre><code>from typing import Literal\nimport discord\nfrom discord.ext import commands\nimport qalib\nfrom qalib.template_engines.formatter import Formatter\nfrom qalib.translators.view import ViewEvents\nbot = commands.AutoShardedBot(command_prefix=\"!\", intents=discord.Intents.all())\nMessages = Literal[\"welcome\"]\nasync def acknowledged(interaction: discord.Interaction):\nawait interaction.response.send_message(\"Acknowledged\", ephemeral=True)\n@bot.command()\n@qalib.qalib_context(Formatter(), \"templates/button.xml\")\nasync def greet(ctx: qalib.QalibContext[Messages]):\nasync def on_check(view: discord.ui.View, interaction: discord.Interaction):\nreturn interaction.user.id == ctx.message.author.id\nawait ctx.rendered_send(\"welcome\", callables={\"greet\": acknowledged}, events={ViewEvents.ON_CHECK: on_check})\n</code></pre>"},{"location":"usage/simple-usage/#menus","title":"Menus","text":"<p>There is also in-built menus, that you can make easily. You just have to define the embeds in a <code>&lt;menu&gt;</code> tag, with a unique <code>key</code> attribute, and you can use that to make a sequential menu (order appears as defined).</p> <pre><code>&lt;discord&gt;\n&lt;menu key=\"menu1\"&gt;\n&lt;pages&gt;\n&lt;message key=\"1\"&gt;\n&lt;embed&gt;\n&lt;title&gt;Page 1&lt;/title&gt;\n&lt;colour&gt;magenta&lt;/colour&gt;\n&lt;fields&gt;\n&lt;field&gt;\n&lt;name&gt;This is the first page&lt;/name&gt;\n&lt;value&gt;Lorem ipsum dolor sit amet, consectetur.&lt;/value&gt;\n&lt;/field&gt;\n&lt;/fields&gt;\n&lt;/embed&gt;\n&lt;/message&gt;\n&lt;message key=\"2\"&gt;\n&lt;embed&gt;\n&lt;title&gt;Page 2&lt;/title&gt;\n&lt;colour&gt;magenta&lt;/colour&gt;\n&lt;fields&gt;\n&lt;field&gt;\n&lt;name&gt;This is the second page&lt;/name&gt;\n&lt;value&gt;tempor incididunt ut labore et dolore magna.&lt;/value&gt;\n&lt;/field&gt;\n&lt;/fields&gt;\n&lt;/embed&gt;\n&lt;/message&gt;\n&lt;message key=\"3\"&gt;\n&lt;embed&gt;\n&lt;title&gt;Page 3&lt;/title&gt;\n&lt;colour&gt;magenta&lt;/colour&gt;\n&lt;fields&gt;\n&lt;field&gt;\n&lt;name&gt;This is the third page&lt;/name&gt;\n&lt;value&gt;Eu non diam phasellus vestibulum lorem sed.&lt;/value&gt;\n&lt;/field&gt;\n&lt;/fields&gt;\n&lt;/embed&gt;\n&lt;/message&gt;\n&lt;/pages&gt;\n&lt;/menu&gt;\n&lt;/discord&gt;\n</code></pre> <p>To render the menu you have to use .rendered_send() method with the key as the first argument, and that will render the menu.</p> <p>You can also add a <code>MenuEvents.ON_CHANGE</code> hook, such that everytime the page changes, the callback is run.</p> <pre><code>from qalib.translators.menu import Menu\nasync def on_change(menu: Menu) -&gt; None:\nprint(menu.index)\n</code></pre> <p>an example of a menu being rendered can be seen here:</p> <pre><code>from typing import Literal\nimport discord\nfrom discord.ext import commands\nimport qalib\nfrom qalib.template_engines.formatter import Formatter\nfrom qalib.translators.menu import Menu, MenuEvents\nbot = commands.AutoShardedBot(command_prefix=\"!\", intents=discord.Intents.all())\nMessages = Literal[\"menu1\"]\n@bot.command()\n@qalib.qalib_context(Formatter(), \"templates/player.xml\")\nasync def test(ctx: qalib.QalibContext[Messages]):\nasync def on_change(menu: Menu):\nprint(menu.index)\nawait ctx.rendered_send(\"menu1\", events={MenuEvents.ON_CHANGE: on_change})\n</code></pre> <p>or you can manually define it as so:</p> <pre><code>from typing import Literal\nimport discord\nfrom discord.ext import commands\nimport qalib\nfrom qalib.template_engines.formatter import Formatter\nbot = commands.AutoShardedBot(command_prefix=\"!\", intents=discord.Intents.all())\nMessages = Literal[\"menu1\"]\n@bot.command()\nasync def test(ctx):\ncontext: qalib.QalibContext[Messages] = qalib.QalibContext(ctx, qalib.Renderer(Formatter(), \"templates/player.xml\"))\nawait context.rendered_send(\"menu1\")\n</code></pre>"},{"location":"usage/simple-usage/#all-message-options","title":"All Message Options","text":"<p>you can read about all the options here</p> <ul> <li>embed</li> </ul> <pre><code>&lt;embed&gt;\n&lt;title&gt;Page 1&lt;/title&gt;\n&lt;colour&gt;magenta&lt;/colour&gt;\n&lt;fields&gt;\n&lt;field&gt;\n&lt;name&gt;This is the first page&lt;/name&gt;\n&lt;value&gt;Lorem ipsum dolor sit amet, consectetur.&lt;/value&gt;\n&lt;/field&gt;\n&lt;/fields&gt;\n&lt;/embed&gt; </code></pre> <ul> <li>embeds</li> </ul> <pre><code>&lt;embeds&gt;\n&lt;embed&gt;\n&lt;title&gt;Page 1&lt;/title&gt;\n&lt;colour&gt;magenta&lt;/colour&gt;\n&lt;fields&gt;\n&lt;field&gt;\n&lt;name&gt;This is the first page&lt;/name&gt;\n&lt;value&gt;Lorem ipsum dolor sit amet, consectetur.&lt;/value&gt;\n&lt;/field&gt;\n&lt;/fields&gt;\n&lt;/embed&gt;\n&lt;embed&gt;\n&lt;title&gt;Page 2&lt;/title&gt;\n&lt;colour&gt;magenta&lt;/colour&gt;\n&lt;fields&gt;\n&lt;field&gt;\n&lt;name&gt;This is the second page&lt;/name&gt;\n&lt;value&gt;tempor incididunt ut labore et dolore magna.&lt;/value&gt;\n&lt;/field&gt;\n&lt;/fields&gt;\n&lt;/embed&gt;\n&lt;/embeds&gt;\n</code></pre> <ul> <li>content</li> </ul> <pre><code>&lt;content&gt;Lorem ipsum dolor sit amet, consectetur.&lt;/content&gt; </code></pre> <ul> <li>tts</li> </ul> <pre><code>&lt;tts&gt;true&lt;/tts&gt;\n</code></pre> <ul> <li>nonce</li> </ul> <pre><code>&lt;nonce&gt;123456789&lt;/nonce&gt;\n</code></pre> <ul> <li>delete_after</li> </ul> <pre><code>&lt;delete_after&gt;15.0&lt;/delete_after&gt;\n</code></pre> <ul> <li>suppress_embeds</li> </ul> <pre><code>&lt;suppress_embeds&gt;true&lt;/suppress_embeds&gt;\n</code></pre> <ul> <li>file</li> </ul> <pre><code>&lt;file&gt;\n&lt;filename&gt;tests/routes/complete_messages.xml&lt;/filename&gt;\n&lt;description&gt;Test 1&lt;/description&gt;\n&lt;spoilers&gt;False&lt;/spoilers&gt;\n&lt;/file&gt;\n</code></pre> <ul> <li>files</li> </ul> <pre><code>&lt;files&gt;\n&lt;file&gt;\n&lt;filename&gt;tests/routes/complete_messages.xml&lt;/filename&gt;\n&lt;description&gt;Test 1&lt;/description&gt;\n&lt;spoilers&gt;False&lt;/spoilers&gt;\n&lt;/file&gt;\n&lt;file&gt;\n&lt;filename&gt;tests/routes/full_embeds.xml&lt;/filename&gt;\n&lt;description&gt;Test 2&lt;/description&gt;\n&lt;spoilers&gt;False&lt;/spoilers&gt;\n&lt;/file&gt;\n&lt;/files&gt;\n</code></pre> <ul> <li>allowed_mentions</li> </ul> <pre><code>&lt;allowed_mentions&gt;\n&lt;everyone mention=\"false\"/&gt;\n&lt;users&gt;\n&lt;user&gt;\n123456789012345678\n        &lt;/user&gt;\n&lt;/users&gt;\n&lt;roles&gt;\n&lt;role&gt;\n123456789012345678\n        &lt;/role&gt;\n&lt;/roles&gt;\n&lt;/allowed_mentions&gt;\n</code></pre> <ul> <li>reference</li> </ul> <pre><code>&lt;reference&gt;\n&lt;message_id&gt;3445347859384389&lt;/message_id&gt;\n&lt;channel_id&gt;234234324324&lt;/channel_id&gt;\n&lt;/reference&gt;\n</code></pre> <ul> <li>mention_author</li> </ul> <pre><code>&lt;mention_author&gt;true&lt;/mention_author&gt;\n</code></pre> <ul> <li>view</li> </ul> <pre><code>&lt;view&gt;\n&lt;components&gt;\n&lt;button key=\"button1\"&gt;\n&lt;style&gt;primary&lt;/style&gt;\n&lt;emoji&gt;\n&lt;name&gt;\ud83e\uddba&lt;/name&gt;\n&lt;/emoji&gt;\n&lt;label&gt;Test Button&lt;/label&gt;\n&lt;url&gt;https://www.discord.com&lt;/url&gt;\n&lt;/button&gt;\n&lt;/components&gt;\n&lt;/view&gt; </code></pre>"}]}